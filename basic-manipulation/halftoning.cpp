//USC EE569 Homework-2 Problem-2 by Xuejing Lei//Two digital halftoning methods: dithering and error diffusion//Email: xjlei1117@gmail.com//Date: February 26, 2017#include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>#include <string.h>using namespace std;int index_dithering(char *fn, int indsiz, int type){	FILE *file, *file1;	int SizeC = 512, SizeR = 512;	char *filename = new char[30];	double threshold = 0.0;	int I2[2][2] = {{0,2},{3,1}};	int I8[8][8] = {{0,32,8,40,2,34,10,42},{48,16,56,24,50,18,58,26},{12,44,4,36,14,46,6,38},{60,28,52,20,62,30,54,22},					{3,35,11,43,1,33,9,41},{51,19,59,27,49,17,57,25},{15,47,7,39,13,45,5,37},{63,31,55,23,61,29,53,21}};	int I4[4][4] = {{0,8,2,10},{12,4,14,6},{3,11,1,9},{15,7,13,5}};	int A4[4][4] = {{14,10,11,15},{9,3,0,4},{8,2,1,5},{13,7,6,12}};	int index[indsiz][indsiz];	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int m=0; m<SizeR; m++){		ImageData[m] = new unsigned char[SizeC];		ImageData_New[m] = new unsigned char[SizeC];	 	fread(ImageData[m], sizeof(unsigned char), SizeC, file);	 			 			 }	fclose(file);	// construct index matrix	for (int i=0; i<indsiz; i++) {		for (int j=0; j<indsiz; j++) {			if (indsiz == 2) index[i][j] = I2[i][j];			else if (indsiz == 8) index[i][j] = I8[i][j];			else if (indsiz == 4 && type == 0) index[i][j] = I4[i][j];			else if (indsiz == 4 && type == 1) index[i][j] = A4[i][j];		}	}	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_dither_");	if (indsiz == 2) strcat(filename, "I2.raw");	else if (indsiz == 8) strcat(filename, "I8.raw");	else if (indsiz == 4 && type == 0) strcat(filename, "I4.raw");	else if (indsiz == 4 && type == 1) strcat(filename, "A4.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}	for (int i=0; i<SizeR; i++){	 	for (int j=0; j<SizeC; j++){	 		threshold = (index[i%indsiz][j%indsiz]+0.5)/(double)indsiz/(double)indsiz*255;	 		if (ImageData[i][j] > threshold) {	 			ImageData_New[i][j] = 255;	 		} else ImageData_New[i][j] = 0;	 	}	 	fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	 }	fclose(file1);		for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] filename;	return 0;}int level4_dithering(char *fn, int type){	FILE *file, *file1;	int SizeC = 512, SizeR = 512;	char *filename = new char[30];	int index[8][8] = {{0,32,8,40,2,34,10,42},{48,16,56,24,50,18,58,26},{12,44,4,36,14,46,6,38},{60,28,52,20,62,30,54,22},					{3,35,11,43,1,33,9,41},{51,19,59,27,49,17,57,25},{15,47,7,39,13,45,5,37},{63,31,55,23,61,29,53,21}};	int indsiz = 8;	double threshold = 0.0;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int m=0; m<SizeR; m++){		ImageData[m] = new unsigned char[SizeC];		ImageData_New[m] = new unsigned char[SizeC];	 	fread(ImageData[m], sizeof(unsigned char), SizeC, file);	 			 			 }	fclose(file);	if (type == 1) {		memset(filename, 0, sizeof(filename));		strcpy(filename, fn);		strcat(filename, "_ditherL4_1.raw");		if (!(file1=fopen(filename,"wb"))) {		cout << "Cannot open file: " << filename << endl;			exit(1);		}		for (int i=0; i<SizeR; i++){		 	for (int j=0; j<SizeC; j++){		 		if (ImageData[i][j] < 64) {		 			ImageData_New[i][j] = 0;		 		} else if (ImageData[i][j] < 128) {		 			ImageData_New[i][j] = 85;		 		} else if (ImageData[i][j] < 192) {		 			ImageData_New[i][j] = 170;		 		} else ImageData_New[i][j] = 255;	 				 	}		 	fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);		 }		fclose(file1);		} else if (type == 2) {		memset(filename, 0, sizeof(filename));		strcpy(filename, fn);		strcat(filename, "_ditherL4_2.raw");		if (!(file1=fopen(filename,"wb"))) {		cout << "Cannot open file: " << filename << endl;			exit(1);		}		for (int i=0; i<SizeR; i++){		 	for (int j=0; j<SizeC; j++){		 		if (ImageData[i][j] < 85) {		 				threshold = (index[i%indsiz][j%indsiz]+0.5)/(double)indsiz/(double)indsiz*85;		 				if (ImageData[i][j] > threshold) ImageData_New[i][j] = 85;		 				else ImageData_New[i][j] = 0;		 			}		 			else if (ImageData[i][j] <= 170) {		 				threshold = (index[i%indsiz][j%indsiz]+0.5)/(double)indsiz/(double)indsiz*85 + 85;		 				if (ImageData[i][j] > threshold) ImageData_New[i][j] = 170;		 				else ImageData_New[i][j] = 85;		 			}		 			else {		 				threshold = (index[i%indsiz][j%indsiz]+0.5)/(double)indsiz/(double)indsiz*85 + 171;		 				if (ImageData[i][j] > threshold) ImageData_New[i][j] = 255;		 				else ImageData_New[i][j] = 170;		 			}		 	}		 	fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);		 }		fclose(file1);	}	for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] filename;	return 0;}int error_diffusion(char *fn, int type, int imp){	FILE *file, *file1;	int SizeC = 512, SizeR = 512;	char *filename = new char[30];	double error = 0.0;	int threshold = 127, threshold2 = 127, threshold3 = 127;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	double **NewD = new double *[SizeR];	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int i=0; i<SizeR; i++){		ImageData[i] = new unsigned char[SizeC];		ImageData_New[i] = new unsigned char[SizeC];		NewD[i] = new double[SizeC];	 	fread(ImageData[i], sizeof(unsigned char), SizeC, file);	 	for (int j=0; j<SizeC; j++) {	 		NewD[i][j] = ImageData[i][j];	 	}	 }	fclose(file);	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_errdif_");	if (type == 0) {		if (imp==0) strcat(filename, "FS.raw");		else if (imp==1) strcat(filename, "FS_Imp.raw");	} else if (type == 1) {		if (imp==0) strcat(filename, "JJN.raw");		else if (imp==1) strcat(filename, "JJN_Imp.raw");	} else if (type == 2) {		if (imp==0) strcat(filename, "St.raw");		else if (imp==1) strcat(filename, "St_Imp.raw");	}	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}	if (type == 0) {								// FS		for (int i=0; i<SizeR; i++){			if (i%2 == 0) {                        //left to right				for (int j=0; j<SizeC; j++){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];							 			if (j > 0 && i<SizeR-1) NewD[i+1][j-1] += error*3.0/16.0;		 			if (i<SizeR-1) NewD[i+1][j] += error*5.0/16.0;		 			if (j < SizeC-1) {		 				NewD[i][j+1] += error*7.0/16.0;		 				if (i<SizeR-1) NewD[i+1][j+1] += error*1.0/16.0;		 						 			} 		 					 		}			} else {                               //right to left 				for (int j=SizeC-1; j>=0; j--){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];		 			if (j < SizeC-1 && i<SizeR-1) NewD[i+1][j+1] += error*3.0/16.0;		 			if (i<SizeR-1) NewD[i+1][j] += error*5.0/16.0;		 			if (j > 0) {		 				NewD[i][j-1] += error*7.0/16.0;		 				if (i<SizeR-1) NewD[i+1][j-1] += error*1.0/16.0;	 							 		}		 		}			}		 			 	fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);		}			} else if (type == 1) {                        // JJN		for (int i=0; i<SizeR; i++){			if (i%2 == 0) {                        //left to right				for (int j=0; j<SizeC; j++){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold2 = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold2 = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold2) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];		 			if (j > 0) {		 				if (i<SizeR-1) NewD[i+1][j-1] += error*5.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j-1] += error*3.0/48.0;		 			}		 			if (j > 1) {		 				if (i<SizeR-1) NewD[i+1][j-2] += error*3.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j-2] += error*1.0/48.0;		 			}		 					 			if (i<SizeR-1) NewD[i+1][j] += error*7.0/48.0;		 			if (i<SizeR-2) NewD[i+2][j] += error*5.0/48.0;		 					 			if (j < SizeC-1) {		 				NewD[i][j+1] += error*7.0/48.0;		 				if (i<SizeR-1) NewD[i+1][j+1] += error*5.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j+1] += error*3.0/48.0;		 			}		 			if (j < SizeC-2) {		 				NewD[i][j+2] += error*5.0/48.0;		 				if (i<SizeR-1) NewD[i+1][j+2] += error*3.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j+2] += error*1.0/48.0;		 			}		 		}			} else {                               //right to left 				for (int j=SizeC-1; j>=0; j--){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold2 = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold2 = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold2) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];		 			if (j <SizeC-1) {		 				if (i<SizeR-1) NewD[i+1][j+1] += error*5.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j+1] += error*3.0/48.0;		 			}		 			if (j <SizeC-2) {		 				if (i<SizeR-1) NewD[i+1][j+2] += error*3.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j+2] += error*1.0/48.0;		 			}		 					 			if (i<SizeR-1) NewD[i+1][j] += error*7.0/48.0;		 			if (i<SizeR-2) NewD[i+2][j] += error*5.0/48.0;		 					 			if (j > 0) {		 				NewD[i][j-1] += error*7.0/48.0;		 				if (i<SizeR-1) NewD[i+1][j-1] += error*5.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j-1] += error*3.0/48.0;		 			}		 			if (j >1) {		 				NewD[i][j-2] += error*5.0/48.0;		 				if (i<SizeR-1) NewD[i+1][j-2] += error*3.0/48.0;		 				if (i<SizeR-2) NewD[i+2][j-2] += error*1.0/48.0;		 			}				}			}			fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);		}	} else if (type == 2) {							// Stucki		for (int i=0; i<SizeR; i++){			if (i%2 == 0) {                        //left to right				for (int j=0; j<SizeC; j++){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold3 = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold3 = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold3) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];		 			if (j > 0) {		 				if (i<SizeR-1) NewD[i+1][j-1] += error*4.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j-1] += error*2.0/42.0;		 			}		 			if (j > 1) {		 				if (i<SizeR-1) NewD[i+1][j-2] += error*2.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j-2] += error*1.0/42.0;		 			}		 					 			if (i<SizeR-1) NewD[i+1][j] += error*8.0/42.0;		 			if (i<SizeR-2) NewD[i+2][j] += error*4.0/42.0;		 					 			if (j < SizeC-1) {		 				NewD[i][j+1] += error*8.0/42.0;		 				if (i<SizeR-1) NewD[i+1][j+1] += error*4.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j+1] += error*2.0/42.0;		 			}		 			if (j < SizeC-2) {		 				NewD[i][j+2] += error*4.0/42.0;		 				if (i<SizeR-1) NewD[i+1][j+2] += error*2.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j+2] += error*1.0/42.0;		 			}		 		}			} else {                               //right to left 				for (int j=SizeC-1; j>=0; j--){					if (imp==1) {						if (j==0 || j==SizeC-1 || i==SizeR-1 || i==0) threshold3 = 127;						else //threshold = 127+(127-ImageData[i][j])*0.2;						threshold3 = 127+(ImageData[i][j-1]+ImageData[i][j]+ImageData[i][j+1])/3.0-ImageData[i][j];					}					if (NewD[i][j] >= threshold3) ImageData_New[i][j] = 255;					else ImageData_New[i][j] = 0;					error = NewD[i][j]-ImageData_New[i][j];		 			if (j <SizeC-1) {		 				if (i<SizeR-1) NewD[i+1][j+1] += error*4.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j+1] += error*2.0/42.0;		 			}		 			if (j <SizeC-2) {		 				if (i<SizeR-1) NewD[i+1][j+2] += error*2.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j+2] += error*1.0/42.0;		 			}		 					 			if (i<SizeR-1) NewD[i+1][j] += error*8.0/42.0;		 			if (i<SizeR-2) NewD[i+2][j] += error*4.0/42.0;		 					 			if (j > 0) {		 				NewD[i][j-1] += error*8.0/42.0;		 				if (i<SizeR-1) NewD[i+1][j-1] += error*4.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j-1] += error*2.0/42.0;		 			}		 			if (j >1) {		 				NewD[i][j-2] += error*4.0/42.0;		 				if (i<SizeR-1) NewD[i+1][j-2] += error*2.0/42.0;		 				if (i<SizeR-2) NewD[i+2][j-2] += error*1.0/42.0;		 			}				}			}			fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);		}				}	fclose(file1);		for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData[i];		delete [] NewD[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] NewD;	delete [] filename;	return 0;}int main(int argc, char *argv[]){	// Check for proper syntax	if (argc < 2){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "program_name man" << endl;		return 0;	}	//Dithering	index_dithering(argv[1], 2, 0);	index_dithering(argv[1], 8, 0);	index_dithering(argv[1], 4, 0); // I4	index_dithering(argv[1], 4, 1); // A4	level4_dithering(argv[1], 1);	level4_dithering(argv[1], 2);	// Error Diffusion	error_diffusion(argv[1], 0, 0); // Floyd-Steinberg	error_diffusion(argv[1], 1, 0); // JJN algorithm	error_diffusion(argv[1], 2, 0); // Stucki allgorithm	// Error Diffusion(improved)	error_diffusion(argv[1], 0, 1); // Floyd-Steinberg	error_diffusion(argv[1], 1, 1); // JJN algorithm	error_diffusion(argv[1], 2, 1); // Stucki allgorithm	return 0;}