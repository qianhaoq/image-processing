//USC EE569 Homework-2 Problem-3 by Xuejing Lei//Morphological Processing: shrinking, thinning, skeletonizing and counting game//Email: xjlei1117@gmail.com//Date: February 26, 2017#include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>#include <string.h> using namespace std;int flagoe = 0; //0-size is odd, 1-size is evenint cal_bond(int data[]){	int b = 0;	for (int i=0; i<9; i++) {		if (data[4] == data[i]) {			if (i==0 || i==2 || i==6 || i==8) b ++;			else if (i==1 || i==3 || i==5 || i==7) b += 2;		}	}	return b;}int filter1(int data[], int bond, int type){	switch (bond) {	case 1:		if (type==0) {			if (data[0]!=0 || data[2]!=0 || data[4]!=0 || data[6]!=0) return 1;		}		break;	case 2:		if (type==0) {			if (data[1]!=0 || data[3]!=0 || data[5]!=0 || data[7]!=0) return 1;		}		break;	case 3:		if (type==0) {			if ((data[2]!=0&&data[5]!=0)||(data[1]!=0&&data[2]!=0)||(data[0]!=0&&data[1]!=0)||(data[0]!=0&&data[3]!=0)||				(data[3]!=0&&data[6]!=0)||(data[6]!=0&&data[7]!=0)||(data[7]!=0&&data[8]!=0)||(data[5]!=0&&data[8]!=0)) 				return 1;		}		break;	case 4:		if (type==1 || type==2) {			if ((data[1]!=0&&data[5]!=0)||(data[1]!=0&&data[3]!=0)||(data[3]!=0&&data[7]!=0)||(data[5]!=0&&data[7]!=0)) 				return 1;		}		if (type==0 || type==1 || type==2) {			if ((data[2]!=0&&data[5]!=0&&data[8]!=0)||(data[0]!=0&&data[1]!=0&&data[2]!=0)||				(data[0]!=0&&data[3]!=0&&data[6]!=0)||(data[6]!=0&&data[7]!=0&&data[8]!=0)) 				return 1;		}		break;	case 5:		if (type==0 || type==1) {			if ((data[0]!=0&&data[1]!=0&&data[5]!=0)||(data[1]!=0&&data[5]!=0&&data[8]!=0)||				(data[1]!=0&&data[2]!=0&&data[3]!=0)||(data[2]!=0&&data[5]!=0&&data[7]!=0)||				(data[1]!=0&&data[2]!=0&&data[5]!=0)||(data[0]!=0&&data[1]!=0&&data[3]!=0)||				(data[3]!=0&&data[6]!=0&&data[7]!=0)||(data[5]!=0&&data[7]!=0&&data[8]!=0)) {				return 1;			}						}		break;	case 6:		if (type==0 || type==1) {			if ((data[0]!=0&&data[1]!=0&&data[5]!=0&&data[8]!=0)||				(data[1]!=0&&data[2]!=0&&data[3]!=0&&data[6]!=0)) 				return 1;		}		if (type==0 || type==1 || type==2) {			if ((data[0]!=0&&data[1]!=0&&data[2]!=0&&data[5]!=0)||(data[1]!=0&&data[2]!=0&&data[5]!=0&&data[8]!=0)||				(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0)||(data[0]!=0&&data[1]!=0&&data[3]!=0&&data[6]!=0)||				(data[0]!=0&&data[3]!=0&&data[6]!=0&&data[7]!=0)||(data[3]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||				(data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||(data[2]!=0&&data[5]!=0&&data[7]!=0&&data[8]!=0)) 				return 1;		}		break;	case 7:		if (type==0 || type==1 || type==2) {			if ((data[0]!=0&&data[1]!=0&&data[2]!=0&&data[5]!=0&&data[8]!=0)||				(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0&&data[6]!=0)||				(data[0]!=0&&data[3]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||				(data[2]!=0&&data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)) 				return 1;		}		break;	case 8:		if (type==0 || type==1 || type==2) {			if ((data[1]!=0&&data[2]!=0&&data[5]!=0&&data[7]!=0&&data[8]!=0)||				(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0&&data[5]!=0)||				(data[0]!=0&&data[1]!=0&&data[3]!=0&&data[6]!=0&&data[7]!=0)||				(data[3]!=0&&data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)) {					return 1;				}		}		break;	case 9:		if (type==0 || type==1 || type==2) {			if ((data[0]!=0&&data[1]!=0&&data[2]!=0&&data[5]!=0&&data[7]!=0&&data[8]!=0)||				(data[1]!=0&&data[2]!=0&&data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||				(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0&&data[5]!=0&&data[6]!=0)||				(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0&&data[5]!=0&&data[8]!=0)||								(data[0]!=0&&data[1]!=0&&data[2]!=0&&data[3]!=0&&data[6]!=0&&data[7]!=0)||				(data[0]!=0&&data[1]!=0&&data[3]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||				(data[0]!=0&&data[3]!=0&&data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)||				(data[2]!=0&&data[3]!=0&&data[5]!=0&&data[6]!=0&&data[7]!=0&&data[8]!=0)) 				return 1;		}		break;	case 10:		if (type==0 || type==1 || type==2) {			if ((data[3]==0)||(data[7]==0)||(data[5]==0)||(data[1]==0))				return 1;		}		break;	case 11:		if (type==2) {			if ((data[0]==0)||(data[2]==0)||(data[6]==0)||(data[8]==0)) {				return 1;			}		}		break;	default:		break;	}	return 0;}int filter2_ST(int data[]){	if (data[1]==0 && data[3]==0 && data[5]==0 && data[6]==0 && data[7]==0 && data[8]==0) {			//spur		if ((data[0]==1 && data[2]==0) || (data[0]==0 && data[2]==1))			return 1;	}	if (data[0]==0 && data[1]==0 && data[2]==0 && data[3]==0 && data[6]==0 && data[8]==0) {			//single4		if ((data[5]==1 && data[7]==0) || (data[5]==0 && data[7]==1))			return 1;	}	if (data[6]==0 && data[7]==0 && data[8]==0) {			//L cluster 1		if ((data[0]==0&&data[1]==0&&data[2]==1&&data[3]==0&&data[5]==1)||			(data[0]==0&&data[1]==1&&data[2]==1&&data[3]==0&&data[5]==0)||			(data[0]==1&&data[1]==1&&data[2]==0&&data[3]==0&&data[5]==0)||			(data[0]==1&&data[1]==0&&data[2]==0&&data[3]==1&&data[5]==0)) {			return 1;		}	}	if (data[0]==0 && data[1]==0 && data[2]==0) {			//L cluster 2		if ((data[3]==1&&data[5]==0&&data[6]==1&&data[7]==0&&data[8]==0)||			(data[3]==0&&data[5]==0&&data[6]==1&&data[7]==1&&data[8]==0)||			(data[3]==0&&data[5]==0&&data[6]==0&&data[7]==1&&data[8]==1)||			(data[3]==0&&data[5]==1&&data[6]==0&&data[7]==0&&data[8]==1)) {			return 1;		}	}	if ((data[0]==0&&data[1]==1&&data[2]==1&&data[3]==1&&data[5]==0&&data[6]==0&&data[7]==0&&data[8]==0)||		(data[0]==1&&data[1]==1&&data[2]==0&&data[3]==0&&data[5]==1&&data[6]==0&&data[7]==0&&data[8]==0)||		(data[0]==0&&data[1]==1&&data[2]==0&&data[3]==0&&data[5]==1&&data[6]==0&&data[7]==0&&data[8]==1)||		(data[0]==0&&data[1]==0&&data[2]==1&&data[3]==0&&data[5]==1&&data[6]==0&&data[7]==1&&data[8]==0)) {			//4-con offset			return 1;	}	if (data[0]==0 && data[3]==0 && data[7]==0 && data[8]==0) {			//spur corner cluster 1		if (data[2]==1&&data[6]==1) {			if (data[5]==1||data[1]==1)				return 1;		}	}	if (data[2]==0 && data[5]==0 && data[6]==0 && data[7]==0) {			//spur corner cluster 2		if (data[0]==1&&data[8]==1) {			if (data[3]==1||data[1]==1)				return 1;		}	}	if (data[0]==0 && data[1]==0 && data[5]==0 && data[8]==0) {			//spur corner cluster 3		if (data[2]==1&&data[6]==1) {			if (data[7]==1||data[3]==1)				return 1;		}	}	if (data[1]==0 && data[2]==0 && data[3]==0 && data[6]==0) {			//spur corner cluster 4		if (data[0]==1&&data[8]==1) {			if (data[7]==1||data[5]==1)				return 1;		}	}	if (data[0]==1 && data[1]==1 && data[3]==1)	{		//corner cluster				flagoe++;		return 1;	}	if ((data[1]==1&&data[3]==1&&data[5]==1&&data[2]==0&&data[7]==0&&data[8]==0)||		(data[1]==1&&data[3]==1&&data[5]==1&&data[0]==0&&data[6]==0&&data[7]==0)||		(data[3]==1&&data[5]==1&&data[7]==1&&data[0]==0&&data[1]==0&&data[6]==0)||		(data[3]==1&&data[5]==1&&data[7]==1&&data[1]==0&&data[2]==0&&data[8]==0)||		(data[1]==1&&data[3]==1&&data[7]==1&&data[5]==0&&data[6]==0&&data[8]==0)||		(data[1]==1&&data[3]==1&&data[7]==1&&data[0]==0&&data[2]==0&&data[5]==0)||		(data[1]==1&&data[5]==1&&data[7]==1&&data[0]==0&&data[2]==0&&data[3]==0)||		(data[1]==1&&data[5]==1&&data[7]==1&&data[3]==0&&data[6]==0&&data[8]==0)) {			//tee-branch			return 1;	}	if (data[0]==1 && data[2]==1) {			//V branch 1		if (data[6]==1||data[7]==1||data[8]==1)			return 1;	}	if (data[0]==1 && data[6]==1) {			//V branch 2		if (data[2]==1||data[5]==1||data[8]==1)			return 1;	}	if (data[6]==1 && data[8]==1) {			//V branch 3		if (data[0]==1||data[1]==1||data[2]==1)			return 1;	}	if (data[2]==1 && data[8]==1) {			//V branch 4		if (data[0]==1||data[3]==1||data[6]==1)			return 1;	}	if ((data[1]==1&&data[5]==1&&data[6]==1&&data[2]==0&&data[3]==0&&data[7]==0)||		(data[1]==1&&data[3]==1&&data[8]==1&&data[0]==0&&data[5]==0&&data[7]==0)||		(data[2]==1&&data[3]==1&&data[7]==1&&data[1]==0&&data[5]==0&&data[6]==0)||		(data[0]==1&&data[5]==1&&data[7]==1&&data[1]==0&&data[3]==0&&data[8]==0)) {			//diagonal branch			return 1;	}	return 0;}int filter2_K(int data[]){	if (data[1]==0 && data[3]==0 && data[5]==0 && data[7]==0) {			//spur		if ((data[0]==0&&data[2]==1&&data[6]==0&&data[8]==0)||(data[0]==0&&data[2]==0&&data[6]==1&&data[8]==0)||			(data[0]==0&&data[2]==0&&data[6]==0&&data[8]==1)||(data[0]==1&&data[2]==0&&data[6]==0&&data[8]==0))			return 1;	}	if (data[0]==0 && data[2]==0 && data[6]==0 && data[8]==0) {			//single4		if ((data[1]==0&&data[3]==1&&data[5]==0&&data[7]==0)||(data[1]==0&&data[3]==0&&data[5]==1&&data[7]==0)||			(data[1]==0&&data[3]==0&&data[5]==0&&data[7]==1)||(data[1]==1&&data[3]==0&&data[5]==0&&data[7]==0))			return 1;	}	if (data[0]==0 && data[2]==0 && data[6]==0 && data[8]==0) {			//L cluster		if ((data[1]==1&&data[3]==0&&data[5]==1&&data[7]==0)||			(data[1]==1&&data[3]==1&&data[5]==0&&data[7]==0)||			(data[1]==0&&data[3]==0&&data[5]==1&&data[7]==1)||			(data[1]==0&&data[3]==1&&data[5]==0&&data[7]==1)) {			return 1;		}	}	if ((data[0]==1 && data[1]==1 && data[3]==1)||(data[5]==1 && data[7]==1 && data[8]==1))	{		//corner cluster				return 1;	}	if ((data[1]==1&&data[3]==1&&data[5]==1)||		(data[1]==1&&data[3]==1&&data[7]==1)||		(data[3]==1&&data[5]==1&&data[7]==1)||		(data[1]==1&&data[5]==1&&data[7]==1)) {			//tee-branch			return 1;	}	if (data[0]==1 && data[2]==1) {			//V branch 1		if (data[6]==1||data[7]==1||data[8]==1)			return 1;	}	if (data[0]==1 && data[6]==1) {			//V branch 2		if (data[2]==1||data[5]==1||data[8]==1)			return 1;	}	if (data[6]==1 && data[8]==1) {			//V branch 3		if (data[0]==1||data[1]==1||data[2]==1)			return 1;	}	if (data[2]==1 && data[8]==1) {			//V branch 4		if (data[0]==1||data[3]==1||data[6]==1)			return 1;	}	if ((data[1]==1&&data[5]==1&&data[6]==1&&data[2]==0&&data[3]==0&&data[7]==0)||		(data[1]==1&&data[3]==1&&data[8]==1&&data[0]==0&&data[5]==0&&data[7]==0)||		(data[2]==1&&data[3]==1&&data[7]==1&&data[1]==0&&data[5]==0&&data[6]==0)||		(data[0]==1&&data[5]==1&&data[7]==1&&data[1]==0&&data[3]==0&&data[8]==0)) {			//diagonal branch			return 1;	}	return 0;}int shrinking(char *fn, int SizeC, int SizeR){	FILE *file, *file1;	char *filename = new char[30];	int Data[9], freq[100];	int bond = 0, flag = 1, sum = 0, size = 0;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	unsigned char **ImageData_Pre = new unsigned char *[SizeR];	int **M = new int *[SizeR];	memset(freq, 0, sizeof(freq));	cout<<"In shrinking: "<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int i=0; i<SizeR; i++){		ImageData[i] = new unsigned char[SizeC];		ImageData_New[i] = new unsigned char[SizeC];		ImageData_Pre[i] = new unsigned char[SizeC];		M[i] = new int[SizeC];	 	fread(ImageData[i], sizeof(unsigned char), SizeC, file);	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		ImageData_New[i][j] = ImageData[i][j];	 		ImageData_Pre[i][j] = ImageData[i][j];	 	}	 }	fclose(file);	for (int i=1; i<SizeR-1; i++){		for (int j=1; j<SizeC-1; j++){			if (ImageData[i-1][j-1]==0 && ImageData[i-1][j]==0 && ImageData[i-1][j+1]==0 &&				ImageData[i][j-1]==0 && ImageData[i][j]!=0 && ImageData[i][j+1]==0 &&				ImageData[i+1][j-1]==0 && ImageData[i+1][j]==0 && ImageData[i+1][j+1]==0)				freq[0]++;		}	}	sum += freq[0]; // total number of squares	cout<<"The total number of squares of size 1 is "<<sum<<endl;	while (flag) {		flagoe = 0;		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		//Initialization!!!!!		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 			M[i][j] = filter1(Data, bond, 0);		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_ST(Data)==0) ImageData_New[i][j] = 0;				}		 	}		 }		int sumpre = sum;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		if (ImageData_New[i-1][j-1]==0 && ImageData_New[i-1][j]==0 && ImageData_New[i-1][j+1]==0 &&					ImageData_New[i][j-1]==0 && ImageData_New[i][j]!=0 && ImageData_New[i][j+1]==0 &&					ImageData_New[i+1][j-1]==0 && ImageData_New[i+1][j]==0 && ImageData_New[i+1][j+1]==0)					sum++;		 	}		}		sum = sum-sumpre;		cout<<"The total number of squares after "<<size<<" iteration is "<<sum<<endl;		// separate odd size square to even size square		if (flagoe!=0) {			freq[size*2] = flagoe;			freq[size*2+1] = sum-sumpre-flagoe;		} else if (flagoe==0) freq[size*2+1] = sum - sumpre;		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}	}	cout<<"The total number of squares is "<<sum<<endl;	cout<<"Iterative number is "<<size-1<<endl;	for (int i=0; i<size*2; i++) {		if (freq[i]!=0) {			if (i!=0) cout<<"The number of squares of size "<<i<<" is "<<freq[i]<<endl;			else cout<<"The number of squares of size "<<i+1<<" is "<<freq[i]<<endl;		}	}	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_S.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData_Pre[i];		delete [] ImageData[i];		delete [] M[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] ImageData_Pre;	delete [] M;	delete [] filename;	return 0;}int thinning(char *fn, int SizeC, int SizeR){	FILE *file, *file1;	char *filename = new char[30];	int Data[9];	int bond = 0, flag = 1, size = 0;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	unsigned char **ImageData_Pre = new unsigned char *[SizeR];	int **M = new int *[SizeR];	cout<<endl<<"In thinning: "<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int i=0; i<SizeR; i++){		ImageData[i] = new unsigned char[SizeC];		ImageData_New[i] = new unsigned char[SizeC];		ImageData_Pre[i] = new unsigned char[SizeC];		M[i] = new int[SizeC];	 	fread(ImageData[i], sizeof(unsigned char), SizeC, file);	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		ImageData_New[i][j] = ImageData[i][j];	 		ImageData_Pre[i][j] = ImageData[i][j];	 	}	 }	fclose(file);	while (flag) {		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 			M[i][j] = filter1(Data, bond, 1);		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_ST(Data)==0) ImageData_New[i][j] = 0;				}		 	}		 }		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}	}	cout<<"Iterative number is "<<size-1<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_T.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData_Pre[i];		delete [] ImageData[i];		delete [] M[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] ImageData_Pre;	delete [] M;	delete [] filename;	return 0;}int skeletonizing(char *fn, int SizeC, int SizeR){	FILE *file, *file1;	char *filename = new char[30];	int Data[9];	int bond = 0, flag = 1, size = 0;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	unsigned char **ImageData_Pre = new unsigned char *[SizeR];	int **M = new int *[SizeR];	cout<<endl<<"In skeletonizing: "<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int i=0; i<SizeR; i++){		ImageData[i] = new unsigned char[SizeC];		ImageData_New[i] = new unsigned char[SizeC];		ImageData_Pre[i] = new unsigned char[SizeC];		M[i] = new int[SizeC];	 	fread(ImageData[i], sizeof(unsigned char), SizeC, file);	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		ImageData_New[i][j] = ImageData[i][j];	 		ImageData_Pre[i][j] = ImageData[i][j];	 	}	 }	fclose(file);	while (flag) {		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 			M[i][j] = filter1(Data, bond, 2);		 			//if (M[i][j]==1) cout<<i<<","<<j<<" ";		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_K(Data)==0) ImageData_New[i][j] = 0;				}		 	}		 }		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}	}	cout<<"Iterative number is "<<size-1<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_K.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData_Pre[i];		delete [] ImageData[i];		delete [] M[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] ImageData_Pre;	delete [] M;	delete [] filename;	return 0;}int count_game(char *fn, int SizeC, int SizeR){	FILE *file, *file1;	char *filename = new char[30];	int Data[9], freq[100];	int bond = 0, flag = 1, sum_bh = 0, sum_wo = 0, sum_sq = 0, sum_ci = 0, size = 0;	unsigned char **ImageData = new unsigned char *[SizeR];	unsigned char **ImageData_New = new unsigned char *[SizeR];	unsigned char **ImageData_Pre = new unsigned char *[SizeR];	int **M = new int *[SizeR];	memset(freq, 0, sizeof(freq));	cout<<endl<<"In counting game: "<<endl;	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, ".raw");	if (!(file=fopen(filename,"rb"))) {		cout << "Cannot open file: " << filename <<endl;		exit(1);	}	for (int i=0; i<SizeR; i++){		ImageData[i] = new unsigned char[SizeC];		ImageData_New[i] = new unsigned char[SizeC];		ImageData_Pre[i] = new unsigned char[SizeC];		M[i] = new int[SizeC];	 	fread(ImageData[i], sizeof(unsigned char), SizeC, file);	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		if (ImageData[i][j]==0) ImageData_New[i][j] = 255;	 		else ImageData_New[i][j] = 0;	 		ImageData_Pre[i][j] = ImageData_New[i][j];	 	}	}	fclose(file);	// shrinking to count black holes	while (flag) {		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		//Initialization!!!!!		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 			M[i][j] = filter1(Data, bond, 0);		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_ST(Data)==0) ImageData_New[i][j] = 0;				}		 	}		}		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}	}	cout<<"The total number of iterations for shrinking black holes is "<<size-1<<endl;	// count black holes and fill holes	for (int i=1; i<SizeR-1; i++){		for (int j=1; j<SizeC-1; j++){		 	if (ImageData_New[i-1][j-1]==0 && ImageData_New[i-1][j]==0 && ImageData_New[i-1][j+1]==0 &&				ImageData_New[i][j-1]==0 && ImageData_New[i][j]!=0 && ImageData_New[i][j+1]==0 &&				ImageData_New[i+1][j-1]==0 && ImageData_New[i+1][j]==0 && ImageData_New[i+1][j+1]==0) {		 		sum_bh++;		 		cout<<"One location of black hole: "<<i<<","<<j<<endl;		 		for (int m=-15; m<=15; m++) {			 		for (int n=-15; n<=15; n++) {			 			if (ImageData[i+m][j+n] == 0) {			 				ImageData[i+m][j+n] = 255;			 				if (ImageData[i+m-1][j+n] == 0) ImageData[i+m-1][j+n] = 255;			 				if (ImageData[i+m+1][j+n] == 0) ImageData[i+m+1][j+n] = 255;			 				if (ImageData[i+m][j+n-1] == 0) ImageData[i+m][j+n-1] = 255;			 				if (ImageData[i+m][j+n+1] == 0) ImageData[i+m][j+n+1] = 255;			 			}			 		}			 	}		 	}			}	}	cout<<"The total number of black holes is "<<sum_bh<<endl;	// write black hole shrinking image into file	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_BH.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		for (int j=0; j<SizeC; j++) {			if (ImageData_New[i][j]==0) ImageData_New[i][j] = 255;			else ImageData_New[i][j] = 0;		}		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	// write black hole filling image into file	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_holefill.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	// count number of white objects after hole filling	for (int i=0; i<SizeR; i++){	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		ImageData_New[i][j] = ImageData[i][j];	 		ImageData_Pre[i][j] = ImageData_New[i][j];	 	}	}	flag = 1;	size = 0;	while (flag) {		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		//Initialization!!!!!		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 			M[i][j] = filter1(Data, bond, 0);		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_ST(Data)==0) ImageData_New[i][j] = 0;				}		 	}		}		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}		if (size==25){			memset(filename, 0, sizeof(filename));			strcpy(filename, fn);			strcat(filename, "_WO_25.raw");			if (!(file1=fopen(filename,"wb"))) {			cout << "Cannot open file: " << filename << endl;				exit(1);			}				for (int i=0; i<SizeR; i++){				fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);			}			fclose(file1);		}	}	cout<<"The total number of iterations for shrinking white objects is "<<size-1<<endl;	for (int i=1; i<SizeR-1; i++){		for (int j=1; j<SizeC-1; j++){		 	if (ImageData_New[i-1][j-1]==0 && ImageData_New[i-1][j]==0 && ImageData_New[i-1][j+1]==0 &&				ImageData_New[i][j-1]==0 && ImageData_New[i][j]!=0 && ImageData_New[i][j+1]==0 &&				ImageData_New[i+1][j-1]==0 && ImageData_New[i+1][j]==0 && ImageData_New[i+1][j+1]==0) {		 		sum_wo++;		 	}			}	}	cout<<"The total number of white objects is "<<sum_wo<<endl;	// write white objects shrinking image into file	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_WO.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	// count number of square and circle objects using thinning after hole filling	for (int i=0; i<SizeR; i++){	 	for (int j=0; j<SizeC; j++) {	 		M[i][j] = 0;	 		ImageData_New[i][j] = ImageData[i][j];	 		ImageData_Pre[i][j] = ImageData_New[i][j];	 	}	}	flag = 1;	size = 0;	while (flag) {		size++;		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		M[i][j] = 0;		 		if (ImageData_New[i][j] == 255) {		 			Data[0] = ImageData_New[i-1][j-1]; Data[1] = ImageData_New[i-1][j]; Data[2] = ImageData_New[i-1][j+1];					Data[3] = ImageData_New[i][j-1]; Data[4] = ImageData_New[i][j]; Data[5] = ImageData_New[i][j+1];					Data[6] = ImageData_New[i+1][j-1]; Data[7] = ImageData_New[i+1][j]; Data[8] = ImageData_New[i+1][j+1];		 			bond = cal_bond(Data);		 					 			M[i][j] = filter1(Data, bond, 1);		 		}		 	}		}		for (int i=1; i<SizeR-1; i++){		 	for (int j=1; j<SizeC-1; j++){		 		ImageData_Pre[i][j] = ImageData_New[i][j];				if (M[i][j]==1) {					Data[0] = M[i-1][j-1]; Data[1] = M[i-1][j]; Data[2] = M[i-1][j+1];					Data[3] = M[i][j-1]; Data[4] = M[i][j]; Data[5] = M[i][j+1];					Data[6] = M[i+1][j-1]; Data[7] = M[i+1][j]; Data[8] = M[i+1][j+1];					if(filter2_ST(Data)==0) ImageData_New[i][j] = 0;				}		 	}		 }		bool jumpoutloop = false;		for (int i=1; i<SizeR-1 && !jumpoutloop; i++){		 	for (int j=1; j<SizeC-1 && !jumpoutloop; j++){		 		if (ImageData_New[i][j] != ImageData_Pre[i][j]) {		 			flag = 1;		 			jumpoutloop = true;		 		} else flag = 0;		 	}		}		if (size==25){			memset(filename, 0, sizeof(filename));			strcpy(filename, fn);			strcat(filename, "_T_25.raw");			if (!(file1=fopen(filename,"wb"))) {			cout << "Cannot open file: " << filename << endl;				exit(1);			}				for (int i=0; i<SizeR; i++){				fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);			}			fclose(file1);		}	}	cout<<"The total number of iterations for thinning white objects is "<<size-1<<endl;	for (int i=1; i<SizeR-1; i++){		for (int j=1; j<SizeC-1; j++){		 	if (ImageData_New[i-1][j-1]==0 && ImageData_New[i-1][j]==0 && ImageData_New[i-1][j+1]==0 &&				ImageData_New[i][j-1]==0 && ImageData_New[i][j]!=0 && ImageData_New[i][j+1]==0 &&				ImageData_New[i+1][j-1]==0 && ImageData_New[i+1][j]==0 && ImageData_New[i+1][j+1]==0) {		 		sum_sq++;		 		cout<<"One location of white square: "<<i<<","<<j<<endl;		 	} else {		 		while (ImageData_New[i][j]!=0) {		 			// cout<<"enter at "<<i<<","<<j<<","<<(int)ImageData_New[i][j]<<endl;		 			if (ImageData_New[i-1][j-1]!=0||ImageData_New[i-1][j]!=0||ImageData_New[i-1][j+1]!=0||		 				ImageData_New[i+1][j-1]!=0||ImageData_New[i+1][j]!=0||ImageData_New[i+1][j+1]!=0) {		 				while (ImageData_New[i][j]!=0) {		 					j++;		 				}		 				break;		 			} else if (ImageData_New[i-1][j-1]==0&&ImageData_New[i-1][j]==0&&ImageData_New[i-1][j+1]==0&&		 						ImageData_New[i+1][j-1]==0&&ImageData_New[i+1][j]==0&&ImageData_New[i+1][j]==0) {		 				if (ImageData_New[i][j+1]==0) {		 					sum_sq++;		 					cout<<"One location of white square (rectangular): "<<i<<","<<j<<endl;		 				}		 				j++;		 			}		 								 		}		 	}		}	}	sum_ci = sum_wo - sum_sq;	cout<<"The total number of white square objects is "<<sum_sq<<endl;	cout<<"The total number of white circle objects is "<<sum_ci<<endl;	// write white objects shrinking image into file	memset(filename, 0, sizeof(filename));	strcpy(filename, fn);	strcat(filename, "_T.raw");	if (!(file1=fopen(filename,"wb"))) {	cout << "Cannot open file: " << filename << endl;		exit(1);	}		for (int i=0; i<SizeR; i++){		fwrite(ImageData_New[i], sizeof(unsigned char), SizeC, file1);	}	fclose(file1);	for (int i=0; i<SizeR; i++) {		delete [] ImageData_New[i];		delete [] ImageData_Pre[i];		delete [] ImageData[i];		delete [] M[i];	}	delete [] ImageData;	delete [] ImageData_New;	delete [] ImageData_Pre;	delete [] M;	delete [] filename;	return 0;}int main(int argc, char *argv[]){	int SizeC = 480, SizeR = 480;	// Check for proper syntax	if (argc < 4){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "program_name squares letterE board" << endl;		return 0;	}	shrinking(argv[1], SizeC, SizeR);	thinning(argv[2], SizeC, SizeR);	skeletonizing(argv[2], SizeC, SizeR);	count_game(argv[3], SizeC, SizeR);	return 0;}